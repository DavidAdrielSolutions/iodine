{"version":3,"file":"iodine.min.esm.js","sources":["../src/iodine.js"],"sourcesContent":["/*\r\n|--------------------------------------------------------------------------\r\n| Iodine - JavaScript Library\r\n|--------------------------------------------------------------------------\r\n|\r\n| This library contains a collection of useful validation rules that can\r\n| be used to quickly verify whether items meet certain conditions.\r\n|\r\n*/\r\nclass Iodine {\r\n  /**\r\n   * Constructor.\r\n   *\r\n   **/\r\n  constructor() {\r\n    this.locale = undefined;\r\n    this.messages = this._defaultMessages();\r\n  }\r\n\r\n  /**\r\n   * @internal.\r\n   *\r\n   **/\r\n  _dateCompare(first, second, type, equals = false) {\r\n    if (!this.isDate(first)) return false;\r\n\r\n    if (!this.isDate(second) && !this.isInteger(second)) return false;\r\n\r\n    second = typeof second === \"number\" ? second : second.getTime();\r\n\r\n    if (type === \"less\" && equals) return first.getTime() <= second;\r\n    if (type === \"less\" && !equals) return first.getTime() < second;\r\n    if (type === \"more\" && equals) return first.getTime() >= second;\r\n    if (type === \"more\" && !equals) return first.getTime() > second;\r\n  }\r\n\r\n  /**\r\n   * @internal.\r\n   *\r\n   **/\r\n  _defaultMessages() {\r\n    return {\r\n      after: `The date must be after: '[PARAM]'`,\r\n      afterOrEqual: `The date must be after or equal to: '[PARAM]'`,\r\n      array: `Value must be an array`,\r\n      before: `The date must be before: '[PARAM]'`,\r\n      beforeOrEqual: `The date must be before or equal to: '[PARAM]'`,\r\n      boolean: `Value must be true or false`,\r\n      date: `Value must be a date`,\r\n      different: `Value must be different to '[PARAM]'`,\r\n      endingWith: `Value must end with '[PARAM]'`,\r\n      email: `Value must be a valid email address`,\r\n      falsy: `Value must be a falsy value (false, 'false', 0 or '0')`,\r\n      in: `Value must be one of the following options: [PARAM]`,\r\n      integer: `Value must be an integer`,\r\n      json: `Value must be a parsable JSON object string`,\r\n      maximum: `Value must not be greater than '[PARAM]' in size or character length`,\r\n      minimum: `Value must not be less than '[PARAM]' in size or character length`,\r\n      notIn: `Value must not be one of the following options: [PARAM]`,\r\n      numeric: `Value must be numeric`,\r\n      optional: `Value is optional`,\r\n      regexMatch: `Value must satisify the regular expression: [PARAM]`,\r\n      required: `Value must be present`,\r\n      same: `Value must be '[PARAM]'`,\r\n      startingWith: `Value must start with '[PARAM]'`,\r\n      string: `Value must be a string`,\r\n      truthy: `Value must be a truthy value (true, 'true', 1 or '1')`,\r\n      url: `Value must be a valid url`,\r\n      uuid: `Value must be a valid UUID`,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Attach a custom validation rule to the library.\r\n   *\r\n   **/\r\n  addRule(name, closure) {\r\n    Iodine.prototype[`is${name[0].toUpperCase()}${name.slice(1)}`] = closure;\r\n  }\r\n\r\n  /**\r\n   * Retrieve an error message for the given rule.\r\n   *\r\n   **/\r\n  getErrorMessage(rule, arg = undefined) {\r\n    let key = rule.split(\":\")[0];\r\n    let param = arg || rule.split(\":\")[1];\r\n\r\n    if ([\"after\", \"afterOrEqual\", \"before\", \"beforeOrEqual\"].includes(key)) {\r\n      param = new Date(parseInt(param)).toLocaleTimeString(this.locale, {\r\n        year: \"numeric\",\r\n        month: \"short\",\r\n        day: \"numeric\",\r\n        hour: \"2-digit\",\r\n        minute: \"numeric\",\r\n      });\r\n    }\r\n\r\n    return [null, undefined].includes(param)\r\n      ? this.messages[key]\r\n      : this.messages[key].replace(\"[PARAM]\", param);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given date is after another given date.\r\n   *\r\n   **/\r\n  isAfter(value, after) {\r\n    return this._dateCompare(value, after, \"more\", false);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given date is after or equal to another given date.\r\n   *\r\n   **/\r\n  isAfterOrEqual(value, after) {\r\n    return this._dateCompare(value, after, \"more\", true);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is an array.\r\n   *\r\n   **/\r\n  isArray(value) {\r\n    return Array.isArray(value);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given date is before another given date.\r\n   *\r\n   **/\r\n  isBefore(value, before) {\r\n    return this._dateCompare(value, before, \"less\", false);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given date is before or equal to another given date.\r\n   *\r\n   **/\r\n  isBeforeOrEqual(value, before) {\r\n    return this._dateCompare(value, before, \"less\", true);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is a boolean.\r\n   *\r\n   **/\r\n  isBoolean(value) {\r\n    return [true, false].includes(value);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is a date object.\r\n   *\r\n   **/\r\n  isDate(value) {\r\n    return (\r\n      value &&\r\n      Object.prototype.toString.call(value) === \"[object Date]\" &&\r\n      !isNaN(value)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is different to another given value.\r\n   *\r\n   **/\r\n  isDifferent(value, different) {\r\n    return value != different;\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value ends with another given value.\r\n   *\r\n   **/\r\n  isEndingWith(value, sub) {\r\n    return this.isString(value) && value.endsWith(sub);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is a valid email address.\r\n   *\r\n   **/\r\n  isEmail(value) {\r\n    return new RegExp(\"^\\\\S+@\\\\S+[\\\\.][0-9a-z]+$\").test(\r\n      String(value).toLowerCase()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is falsy.\r\n   *\r\n   **/\r\n  isFalsy(value) {\r\n    return [0, \"0\", false, \"false\"].includes(value);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is within the given array of options.\r\n   *\r\n   **/\r\n  isIn(value, options) {\r\n    options = typeof options === \"string\" ? options.split(\",\") : options;\r\n\r\n    return options.includes(value);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is an integer.\r\n   *\r\n   **/\r\n  isInteger(value) {\r\n    return (\r\n      Number.isInteger(value) && parseInt(value).toString() === value.toString()\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is a JSON string.\r\n   *\r\n   **/\r\n  isJson(value) {\r\n    try {\r\n      return typeof JSON.parse(value) === \"object\";\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value meets the given maximum limit.\r\n   *\r\n   **/\r\n  isMaximum(value, limit) {\r\n    value = typeof value === \"string\" ? value.length : value;\r\n\r\n    return parseFloat(value) <= limit;\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value meets the given minimum limit.\r\n   *\r\n   **/\r\n  isMinimum(value, limit) {\r\n    value = typeof value === \"string\" ? value.length : value;\r\n\r\n    return parseFloat(value) >= limit;\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is not within the given array of options.\r\n   *\r\n   **/\r\n  isNotIn(value, options) {\r\n    return !this.isIn(value, options);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is numeric (an integer or a float).\r\n   *\r\n   **/\r\n  isNumeric(value) {\r\n    return !isNaN(parseFloat(value)) && isFinite(value);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is optional.\r\n   *\r\n   **/\r\n  isOptional(value) {\r\n    return [null, undefined, \"\"].includes(value);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value satisifies the given regular expression.\r\n   *\r\n   **/\r\n  isRegexMatch(value, expression) {\r\n    return new RegExp(expression).test(String(value));\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is present.\r\n   *\r\n   **/\r\n  isRequired(value) {\r\n    return !this.isOptional(value);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is the same as another given value.\r\n   *\r\n   **/\r\n  isSame(value, same) {\r\n    return value == same;\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value starts with another given value.\r\n   *\r\n   **/\r\n  isStartingWith(value, sub) {\r\n    return this.isString(value) && value.startsWith(sub);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is a string.\r\n   *\r\n   **/\r\n  isString(value) {\r\n    return typeof value === \"string\";\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is truthy.\r\n   *\r\n   **/\r\n  isTruthy(value) {\r\n    return [1, \"1\", true, \"true\"].includes(value);\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is a valid URL.\r\n   *\r\n   **/\r\n  isUrl(value) {\r\n    return new RegExp(\r\n      \"^(https?:\\\\/\\\\/)?((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.)+[a-z]{2,}|((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*(\\\\?[;&a-z\\\\d%_.~+=-]*)?(\\\\#[-a-z\\\\d_]*)?$\"\r\n    ).test(String(value).toLowerCase());\r\n  }\r\n\r\n  /**\r\n   * Determine if the given value is a valid UUID.\r\n   *\r\n   **/\r\n  isUuid(value) {\r\n    return new RegExp(\r\n      \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"\r\n    ).test(String(value).toLowerCase());\r\n  }\r\n\r\n  /**\r\n   * Determine whether the given value meets the given rules.\r\n   *\r\n   **/\r\n  is(value, rules = []) {\r\n    if (!rules.length) return true;\r\n\r\n    if (rules[0] === \"optional\" && this.isOptional(value)) return true;\r\n\r\n    for (let index in rules) {\r\n      if (rules[index] === \"optional\") continue;\r\n\r\n      let rule =\r\n        rules[index].split(\":\")[0][0].toUpperCase() +\r\n        rules[index].split(\":\")[0].slice(1);\r\n\r\n      let result = this[`is${rule}`].apply(this, [\r\n        value,\r\n        rules[index].split(\":\")[1],\r\n      ]);\r\n\r\n      if (!result) return rules[index];\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Determine whether the given value meets the given rules.\r\n   * @returns true if the item passes every rule, otherwise returns false\r\n   **/\r\n   isValid(value, rules = []) {\r\n    return this.is(value, rules) === true;\r\n  }\r\n\r\n  /**\r\n   * Replace the default error messages with a new set.\r\n   *\r\n   **/\r\n  setErrorMessages(messages) {\r\n    this.messages = messages;\r\n  }\r\n\r\n  /**\r\n   * Replace the default locale with a new value.\r\n   *\r\n   **/\r\n  setLocale(locale) {\r\n    this.locale = locale;\r\n  }\r\n}\r\n\r\n/**\r\n * Create an instance of the library.\r\n *\r\n **/\r\nwindow.Iodine = new Iodine();\r\n"],"names":["Iodine","constructor","this","locale","undefined","messages","_defaultMessages","_dateCompare","first","second","type","equals","isDate","isInteger","getTime","after","afterOrEqual","array","before","beforeOrEqual","boolean","date","different","endingWith","email","falsy","in","integer","json","maximum","minimum","notIn","numeric","optional","regexMatch","required","same","startingWith","string","truthy","url","uuid","addRule","name","closure","prototype","toUpperCase","slice","getErrorMessage","rule","arg","key","split","param","includes","Date","parseInt","toLocaleTimeString","year","month","day","hour","minute","replace","isAfter","value","isAfterOrEqual","isArray","Array","isBefore","isBeforeOrEqual","isBoolean","Object","toString","call","isNaN","isDifferent","isEndingWith","sub","isString","endsWith","isEmail","RegExp","test","String","toLowerCase","isFalsy","isIn","options","Number","isJson","JSON","parse","e","isMaximum","limit","length","parseFloat","isMinimum","isNotIn","isNumeric","isFinite","isOptional","isRegexMatch","expression","isRequired","isSame","isStartingWith","startsWith","isTruthy","isUrl","isUuid","is","rules","index","apply","isValid","setErrorMessages","setLocale","window"],"mappings":"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"}